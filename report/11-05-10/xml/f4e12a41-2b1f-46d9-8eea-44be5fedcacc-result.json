{"name": "支付信息", "status": "broken", "statusDetails": {"message": "TypeError: exceptions must derive from BaseException", "trace": "self = <common.com_assert.ComAssert object at 0x0000000004B23588>\nassert_type = 'eq', ex_value = ['content.msg', 'ok']\nresponse = <Response [405]>\n\n    def assert_content(self, assert_type, ex_value, response):\n        \"\"\"\n        判断content的内容是否如预期\n        :param assert_type:\n        :param ex_value:\n        :param response:\n        :return:\n        \"\"\"\n        keys=str()\n        ex_content=str()\n        re_content = str()\n        try:\n            # 把\"content.xx.yy\"转成[\"xx.yy\"]再转成\"xx.yy\"\n            keys = str(ex_value[0].split(\"content.\")[1:][0])\n            ex_content = ex_value[1]\n    \n>           json_content = json.loads(response.content)  # byte转dict\n\ncommon\\com_assert.py:229: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ns = '<html>\\r\\n<head><title>405 Not Allowed</title></head>\\r\\n<body bgcolor=\"white\">\\r\\n<center><h1>405 Not Allowed</h1></center>\\r\\n<hr><center>openresty</center>\\r\\n</body>\\r\\n</html>\\r\\n'\nencoding = None, cls = None, object_hook = None, parse_float = None\nparse_int = None, parse_constant = None, object_pairs_hook = None, kw = {}\n\n    def loads(s, *, encoding=None, cls=None, object_hook=None, parse_float=None,\n            parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):\n        \"\"\"Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance\n        containing a JSON document) to a Python object.\n    \n        ``object_hook`` is an optional function that will be called with the\n        result of any object literal decode (a ``dict``). The return value of\n        ``object_hook`` will be used instead of the ``dict``. This feature\n        can be used to implement custom decoders (e.g. JSON-RPC class hinting).\n    \n        ``object_pairs_hook`` is an optional function that will be called with the\n        result of any object literal decoded with an ordered list of pairs.  The\n        return value of ``object_pairs_hook`` will be used instead of the ``dict``.\n        This feature can be used to implement custom decoders that rely on the\n        order that the key and value pairs are decoded (for example,\n        collections.OrderedDict will remember the order of insertion). If\n        ``object_hook`` is also defined, the ``object_pairs_hook`` takes priority.\n    \n        ``parse_float``, if specified, will be called with the string\n        of every JSON float to be decoded. By default this is equivalent to\n        float(num_str). This can be used to use another datatype or parser\n        for JSON floats (e.g. decimal.Decimal).\n    \n        ``parse_int``, if specified, will be called with the string\n        of every JSON int to be decoded. By default this is equivalent to\n        int(num_str). This can be used to use another datatype or parser\n        for JSON integers (e.g. float).\n    \n        ``parse_constant``, if specified, will be called with one of the\n        following strings: -Infinity, Infinity, NaN.\n        This can be used to raise an exception if invalid JSON numbers\n        are encountered.\n    \n        To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\n        kwarg; otherwise ``JSONDecoder`` is used.\n    \n        The ``encoding`` argument is ignored and deprecated.\n    \n        \"\"\"\n        if isinstance(s, str):\n            if s.startswith('\\ufeff'):\n                raise JSONDecodeError(\"Unexpected UTF-8 BOM (decode using utf-8-sig)\",\n                                      s, 0)\n        else:\n            if not isinstance(s, (bytes, bytearray)):\n                raise TypeError('the JSON object must be str, bytes or bytearray, '\n                                'not {!r}'.format(s.__class__.__name__))\n            s = s.decode(detect_encoding(s), 'surrogatepass')\n    \n        if (cls is None and object_hook is None and\n                parse_int is None and parse_float is None and\n                parse_constant is None and object_pairs_hook is None and not kw):\n>           return _default_decoder.decode(s)\n\nD:\\python3.6\\lib\\json\\__init__.py:354: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <json.decoder.JSONDecoder object at 0x00000000036FBCF8>\ns = '<html>\\r\\n<head><title>405 Not Allowed</title></head>\\r\\n<body bgcolor=\"white\">\\r\\n<center><h1>405 Not Allowed</h1></center>\\r\\n<hr><center>openresty</center>\\r\\n</body>\\r\\n</html>\\r\\n'\n_w = <built-in method match of _sre.SRE_Pattern object at 0x0000000003680DB0>\n\n    def decode(self, s, _w=WHITESPACE.match):\n        \"\"\"Return the Python representation of ``s`` (a ``str`` instance\n        containing a JSON document).\n    \n        \"\"\"\n>       obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n\nD:\\python3.6\\lib\\json\\decoder.py:339: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <json.decoder.JSONDecoder object at 0x00000000036FBCF8>\ns = '<html>\\r\\n<head><title>405 Not Allowed</title></head>\\r\\n<body bgcolor=\"white\">\\r\\n<center><h1>405 Not Allowed</h1></center>\\r\\n<hr><center>openresty</center>\\r\\n</body>\\r\\n</html>\\r\\n'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n        a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n    \n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n    \n        \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\nD:\\python3.6\\lib\\json\\decoder.py:357: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <common.com_manage.ComManage object at 0x0000000004B23080>\nrequest_dict = {'data': \"{'json': {'order_id': 'ZSCS159538737200000060'}}\", 'header': {'Authorization': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJI...QdY2dFmAvRw2TtOlUcL1vW - xk'}, 'method': 'post', 'url': 'https://sandbox-lingji.jinhuiaa.com/api/payments/config', ...}\n\n    def assert_manner(self, request_dict):\n        \"\"\"\n        根据测试用例的validate部分的判断类型（content/headers/status_code），调用不同的判断方法\n        :param request_dict:\n        :return: 全通过则返回True\n        \"\"\"\n    \n        try:\n            # params = request_dict[0][0]\n            # ex_validates = self.validate_manner(params[\"validate\"])\n            # response = self.request_manner(params)\n            print(request_dict[\"validate\"])\n            ex_validates = self.validate_manner(request_dict[\"validate\"])\n            print(ex_validates)\n            response = self.request_manner(request_dict)\n            print(response)\n    \n            for key in ex_validates:\n                values = ex_validates[key]\n    \n                if len(values) >= 1:\n                    asssert_type = key\n                    for value in values:\n                        value_start = value[0].split(\".\")[0]\n                        if value_start.startswith(\"status_code\"):\n                            assert self.com_assert.assert_code(asssert_type, value, response)\n                        elif value_start.startswith(\"headers\"):\n                            assert self.com_assert.assert_headers(asssert_type, value, response)\n                        elif value_start.startswith(\"content\"):\n>                           assert self.com_assert.assert_content(asssert_type, value, response)\n\ncommon\\com_manage.py:195: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <common.com_assert.ComAssert object at 0x0000000004B23588>\nassert_type = 'eq', ex_value = ['content.msg', 'ok']\nresponse = <Response [405]>\n\n    def assert_content(self, assert_type, ex_value, response):\n        \"\"\"\n        判断content的内容是否如预期\n        :param assert_type:\n        :param ex_value:\n        :param response:\n        :return:\n        \"\"\"\n        keys=str()\n        ex_content=str()\n        re_content = str()\n        try:\n            # 把\"content.xx.yy\"转成[\"xx.yy\"]再转成\"xx.yy\"\n            keys = str(ex_value[0].split(\"content.\")[1:][0])\n            ex_content = ex_value[1]\n    \n            json_content = json.loads(response.content)  # byte转dict\n            # jsonpath_rw，根据key（\"xx.yy.zz\"），返回dict中该key的值\n            re_content = [match.value for match in parse(str(keys)).find(json_content)][0]\n            return self.assert_result(assert_type, ex_content, re_content)\n        except Exception as es:\n            logging.error(\n              \"content判断失败或响应文本不是json格式，判断类型是\"+assert_type+\", 预期值：\"+ex_content+\", content的key是：\"+keys+\",实际值：\"+re_content)\n    \n>           raise (\"content判断失败或响应文本不是json格式，判断类型是\"+assert_type+\", 预期值：\"+ex_content+\", content的key是：\"+keys+\",实际值：\"+re_content)\nE           TypeError: exceptions must derive from BaseException\n\ncommon\\com_assert.py:237: TypeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <testecase.case.test_test.Testtest object at 0x0000000004B23CF8>\nparam = {'data': \"{'json': {'order_id': 'ZSCS159538737200000060'}}\", 'header': {'Authorization': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJI...QdY2dFmAvRw2TtOlUcL1vW - xk'}, 'method': 'post', 'url': 'https://sandbox-lingji.jinhuiaa.com/api/payments/config', ...}\ntitle = '支付信息'\n\n    @allure.title(\"{title}\")# 测试用例名称\n    @pytest.mark.parametrize(\"param, title\", test_params)# 测试用例参数化：参数名，列表数据\n    def test_login(self, param, title):\n>       result = ComManage().assert_manner(param)\n\ntestecase\\case\\test_test.py:28: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <common.com_manage.ComManage object at 0x0000000004B23080>\nrequest_dict = {'data': \"{'json': {'order_id': 'ZSCS159538737200000060'}}\", 'header': {'Authorization': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJI...QdY2dFmAvRw2TtOlUcL1vW - xk'}, 'method': 'post', 'url': 'https://sandbox-lingji.jinhuiaa.com/api/payments/config', ...}\n\n    def assert_manner(self, request_dict):\n        \"\"\"\n        根据测试用例的validate部分的判断类型（content/headers/status_code），调用不同的判断方法\n        :param request_dict:\n        :return: 全通过则返回True\n        \"\"\"\n    \n        try:\n            # params = request_dict[0][0]\n            # ex_validates = self.validate_manner(params[\"validate\"])\n            # response = self.request_manner(params)\n            print(request_dict[\"validate\"])\n            ex_validates = self.validate_manner(request_dict[\"validate\"])\n            print(ex_validates)\n            response = self.request_manner(request_dict)\n            print(response)\n    \n            for key in ex_validates:\n                values = ex_validates[key]\n    \n                if len(values) >= 1:\n                    asssert_type = key\n                    for value in values:\n                        value_start = value[0].split(\".\")[0]\n                        if value_start.startswith(\"status_code\"):\n                            assert self.com_assert.assert_code(asssert_type, value, response)\n                        elif value_start.startswith(\"headers\"):\n                            assert self.com_assert.assert_headers(asssert_type, value, response)\n                        elif value_start.startswith(\"content\"):\n                            assert self.com_assert.assert_content(asssert_type, value, response)\n            return True\n    \n        except Exception as es:\n            logging.error(\"异常判断类型：{key},判断值是{value}，响应数据是{response.content}\")\n>           raise (\"异常判断类型：{key}，判断值是{value}，响应数据是{response.content}\")\nE           TypeError: exceptions must derive from BaseException\n\ncommon\\com_manage.py:200: TypeError"}, "attachments": [{"name": "请求地址：", "source": "15770656-079b-49e2-b944-6f168e881bb6-attachment.attach"}, {"name": "请求方法", "source": "1ac2451e-6af0-452e-b5fa-21f780630aa0-attachment.attach"}, {"name": "请求头：", "source": "aa67c6a8-22d3-479f-be29-65d2a1be99b7-attachment.attach"}, {"name": "请求data：", "source": "aede2388-a627-4141-880d-a998b08664d7-attachment.attach"}, {"name": "log", "source": "b2c3ee22-eb51-4dae-9073-c904c6b94e95-attachment.txt", "type": "text/plain"}], "parameters": [{"name": "param", "value": "{'url': 'https://sandbox-lingji.jinhuiaa.com/api/payments/config', 'method': 'post', 'data': \"{'json': {'order_id': 'ZSCS159538737200000060'}}\", 'header': {'Authorization': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC95ZGFwaS5saW5naGl0LmNvbSIsImF1ZCI6IjE1NzYwMzQ4MDgwMDAwMDA0MCIsImlhdCI6MTU4MzIwNDAwOSwiZXhwIjoxNjE0NzQwMDA5fQ.NWjUOE2kAaPbufulY0QdY2dFmAvRw2TtOlUcL1vW - xk'}, 'validate': \"[{'eq': ['content.msg', 'ok']}, {'contains': ['content.msg', '失败']}]\"}"}, {"name": "title", "value": "'支付信息'"}], "start": 1604543143361, "stop": 1604543143397, "uuid": "56b73dc9-b3f5-4cac-8bdc-5f948e1c826e", "historyId": "c6b2b00b21a70dd148388523465bf213", "testCaseId": "87a2a285daab21fd8e7fb422bb58eb50", "fullName": "testecase.case.test_test.Testtest#test_login", "labels": [{"name": "feature", "value": "test接口"}, {"name": "epic", "value": "xxx"}, {"name": "parentSuite", "value": "testecase.case"}, {"name": "suite", "value": "test_test"}, {"name": "subSuite", "value": "Testtest"}, {"name": "host", "value": "6AALIUSAHJS1WHR"}, {"name": "thread", "value": "6256-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "testecase.case.test_test"}]}